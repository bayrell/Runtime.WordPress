/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.WordPress.App;

use Runtime.re;
use Runtime.DateTime;
use Runtime.ORM.Connection;
use Runtime.ORM.Cursor;
use Runtime.ORM.Query;
use Runtime.ORM.QueryField;
use Runtime.ORM.QueryResult;
use Runtime.ORM.Relation;
use Runtime.Web.BaseApi;
use Runtime.Web.Annotations.ApiMethod;


class PostApi extends BaseApi
{
	/**
	 * Returns api name
	 */
	pure string getApiName() => "runtime.wordpress.post";
	
	
	/**
	 * Returns allowed fields
	 */
	Collection getAllowedFields(Collection fields)
	{
		Collection post_fields = [
			"ID",
			"post_title",
			"post_name",
			"post_content",
			"post_status",
			"post_type",
			"post_modified",
			"post_modified_gmt",
		];
		Dict post_fields_map = post_fields.transition(
			int (string name, int pos) => [pos, name]
		);
		return fields.filter(
			bool (string name) use (post_fields_map) => post_fields_map.has(name)
		);
	}
	
	
	/**
	 * Action search
	 */
	@ApiMethod
	async void actionSearch()
	{
		Connection conn = Connection::get("prefix");
		
		bool found_rows = this.post_data.get("found_rows", true);
		int post_id = (int)this.post_data.get("post_id");
		string post_type = this.post_data.get("post_type");
		int page = this.post_data.get("page", 1);
		int pages = 0;
		int limit = this.post_data.get("limit");
		if (limit < 0) limit = 1;
		if (limit > 100) limit = 100;
		
		/* Get fields */
		Collection fields = this.post_data.get("fields");
		if (fields == null) fields = [
			"ID",
			"post_title",
			"post_name",
			"post_content",
		];
		fields = this.getAllowedFields(fields);
		
		/* Build query */
		Query q = new Query()
			.select("posts")
			.where("posts.post_type", "=", post_type)
			.where("posts.post_status", "=", "publish")
			.orderBy("posts.post_modified_gmt", "desc")
			.page(page - 1).limit(limit)
		;
		
		/* Found rows */
		if (found_rows) q.calcFoundRows(true);
		
		/* Set post id */
		if (post_id > 0)
		{
			int post_id = (int)this.post_data.get("post_id");
			q.where("posts.ID", "=", post_id);
			q.calcFoundRows(false);
		}
		
		/* Add fields */
		for (int i=0; i<fields.count(); i++)
		{
			string field_name = fields.get(i);
			q.addField(new QueryField("posts", field_name));
		}
		
		Cursor c = await conn.execute(q);
		QueryResult res = await c.fetchAll(q);
		
		page = c.getPage() + 1;
		pages = c.getPages();
		
		await c.close();
		
		/* Transform items */
		Collection items = res.toCollection();
		items = items.map(
			Dict (Relation item) use (fields) => item.intersect(fields)
		);
		
		/* Set result */
		this.result.success({
			"data": {
				"items": items,
				"page": page,
				"pages": pages,
			}
		});
	}
	
	
	/**
	 * Returns archive
	 */
	@ApiMethod
	async void getArchive()
	{
		Connection conn = Connection::get("prefix");
		Collection items = [];
		
		/* Build query */
		Query q = new Query()
			.select("posts")
			.distinct(true)
			.addRawField("DATE_FORMAT(`posts`.`post_date_gmt`, '%Y-%m') as `post_date`")
			.where("post_type", "=", "post")
			.where("post_status", "=", "publish")
			.orderBy("post_date", "desc")
		;
		
		items = await conn.fetchAll(q);
		
		/* Transform items */
		items = items.map( string (Dict item) => item.get("post_date") );
		
		/* Set result */
		this.result.success({
			"data": {
				"items": items,
			}
		});
	}
	
	
	/**
	 * Action categories
	 */
	@ApiMethod
	async void getCategories()
	{
		Connection conn = Connection::get("prefix");
		Collection items = [];
		
		string taxonomy_name = this.post_data.get("taxonomy", "");
		
		Query q = new Query()
			.select("terms")
			.addFields([
				"terms.term_id as term_id",
				"terms.name as name",
				"terms.slug as slug",
				"term_taxonomy.taxonomy as taxonomy",
				"term_taxonomy.parent as parent_id",
				"term_taxonomy.count as count",
			])
			.where("term_taxonomy.taxonomy", "=", taxonomy_name)
			.innerJoin("term_taxonomy", ["term_taxonomy.term_id = terms.term_id"])
			.orderBy("terms.name", "asc")
		;
		
		QueryResult res = await conn.fetchAll(q);
		
		/* Transform items */
		Collection fields = [
			"term_id",
			"name",
			"slug",
			"taxonomy",
			"parent_id",
			"count",
		];
		Collection items = res.toCollection();
		items = items.map(
			Dict (Relation item) use (fields)
			{
				item = item.intersect(fields);
				item.set("count", (int)item.get("count"));
				item.set("parent_id", (int)item.get("parent_id"));
				item.set("term_id", (int)item.get("term_id"));
				return item;
			}
		);
		
		/* Set result */
		this.result.success({
			"data": {
				"items": items,
			}
		});
	}
}